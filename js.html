<script>
  /**
   * =========================================================================
   * GIGA Standard リファクタリング v2
   * ファイル: js.html (クライアント側ロジック)
   * 概要: 画面遷移廃止、シームレスな結果表示と再スタート、操作性改善
   * =========================================================================
   */

  // --- グローバル変数 ---
  let startTime;
  let timerInterval;
  let currentMode = '';
  let currentCount = 0;
  let finalTime = 0;
  let finalScore = 0;
  let tableData = { rows: [], cols: [] }; 

  let canvases = [];
  let ctxs = [];
  let isDrawing = [false, false];
  let lastX = [0, 0];
  let lastY = [0, 0];
  let isCanvasDirty = [false, false];
  
  let tfModel = null;
  let ocrTimer = null;
  let sounds = {};

  let lastActiveCell = null;

  let appSettings = {
    sound: true,
    handwriting: true,
    numpad: false,
    autoScore: true,
    inputPosition: 'right'
  };

  // --- 初期化処理 ---
  window.onload = function() {
    loadSettings();
    initCanvas();
    window.addEventListener('resize', resizeCanvas);
    previewTable();
    initAIAndAudio();
    setupKeyboardEvents(); 
  };

  // --- ★設定管理処理 ---
  function loadSettings() {
    const saved = localStorage.getItem('giga100masu_settings');
    if (saved) {
      try {
        appSettings = { ...appSettings, ...JSON.parse(saved) };
      } catch(e) { console.error("設定読み込みエラー"); }
    }
    applySettings();
  }

  function openSettings() {
    document.getElementById('setting-sound').checked = appSettings.sound;
    document.getElementById('setting-handwriting').checked = appSettings.handwriting;
    document.getElementById('setting-numpad').checked = appSettings.numpad;
    document.getElementById('setting-autoScore').checked = appSettings.autoScore;
    document.getElementById('setting-position').value = appSettings.inputPosition;
    
    const modal = new bootstrap.Modal(document.getElementById('settingsModal'));
    modal.show();
  }

  window.saveSettings = function() {
    appSettings.sound = document.getElementById('setting-sound').checked;
    appSettings.handwriting = document.getElementById('setting-handwriting').checked;
    appSettings.numpad = document.getElementById('setting-numpad').checked;
    appSettings.autoScore = document.getElementById('setting-autoScore').checked;
    appSettings.inputPosition = document.getElementById('setting-position').value;
    
    localStorage.setItem('giga100masu_settings', JSON.stringify(appSettings));
    applySettings();
    
    const modal = bootstrap.Modal.getInstance(document.getElementById('settingsModal'));
    modal.hide();
  };

  function applySettings() {
    document.getElementById('handwriting-area').style.display = appSettings.handwriting ? 'block' : 'none';
    document.getElementById('numpad-area').style.display = appSettings.numpad ? 'block' : 'none';
    
    const colInput = document.getElementById('col-input');
    if (appSettings.inputPosition === 'left') {
      colInput.style.order = "-1";
    } else {
      colInput.style.order = "1"; 
    }

    const manualBtn = document.getElementById('manual-finish-btn');
    if (document.getElementById('start-btn').style.display === 'none') {
      manualBtn.style.display = appSettings.autoScore ? 'none' : 'inline-block';
    }

    if (appSettings.handwriting) resizeCanvas();
  }

  function initAIAndAudio() {
    const statusEl = document.getElementById('ocr-status');
    statusEl.innerHTML = '<span class="spinner-border spinner-border-sm text-primary" style="width: 1rem; height: 1rem;"></span> AIと音声をじゅんび中...';
    
    google.script.run.withSuccessHandler(function(audioData) {
      if(audioData.correct) sounds.correct = new Audio("data:audio/mp3;base64," + audioData.correct);
      if(audioData.incorrect) sounds.incorrect = new Audio("data:audio/mp3;base64," + audioData.incorrect);
      if(audioData.end) sounds.end = new Audio("data:audio/mp3;base64," + audioData.end);
    }).loadAudioData();

    google.script.run.withSuccessHandler(async function(modelData) {
      if (!modelData.success) {
        statusEl.innerText = "AIのじゅんびに失敗しました";
        return;
      }
      try {
        const modelTopology = JSON.parse(modelData.jsonStr);
        const binaryString = window.atob(modelData.binBase64);
        const bytes = new Uint8Array(binaryString.length);
        for (let i = 0; i < binaryString.length; i++) {
          bytes[i] = binaryString.charCodeAt(i);
        }
        
        const customIOHandler = {
          load: async () => {
            return {
              modelTopology: modelTopology.modelTopology,
              weightSpecs: modelTopology.weightsManifest[0].weights,
              weightData: bytes.buffer,
              format: 'graph-model'
            };
          }
        };
        
        tfModel = await tf.loadGraphModel(customIOHandler);
        statusEl.innerText = "手書きで自動入力できます！";
      } catch (e) {
        console.error("TF初期化エラー:", e);
        statusEl.innerText = "AIのじゅんびに失敗しました";
      }
    }).loadModelData();
  }

  function setupKeyboardEvents() {
    document.addEventListener('keydown', function(e) {
      if (document.getElementById('start-btn').style.display !== 'none') return;

      if (e.code === 'Space') {
        if (e.target.tagName === 'INPUT' || document.activeElement.tagName === 'INPUT') {
          e.preventDefault();
        }
        focusFirstEmptyCell();
        return;
      }

      if (e.target.classList.contains('calc-input')) {
        const r = parseInt(e.target.getAttribute('data-row'), 10);
        const c = parseInt(e.target.getAttribute('data-col'), 10);
        let nextR = r;
        let nextC = c;

        if (e.key === 'Enter') {
          e.preventDefault();
          moveToNextCell(r, c); 
          return;
        } else if (e.key === 'ArrowRight') {
          e.preventDefault();
          nextC = c + 1;
          if (nextC >= 10) { nextC = 0; nextR++; }
        } else if (e.key === 'ArrowLeft') {
          e.preventDefault();
          nextC = c - 1;
          if (nextC < 0) { nextC = 9; nextR--; }
        } else if (e.key === 'ArrowDown') {
          e.preventDefault();
          nextR = r + 1;
        } else if (e.key === 'ArrowUp') {
          e.preventDefault();
          nextR = r - 1;
        } else {
          return; 
        }

        const nextInput = document.querySelector(`input[data-row="${nextR}"][data-col="${nextC}"]`);
        if (nextInput) nextInput.focus();
      }
    });
  }

  window.focusFirstEmptyCell = function() {
    const allInputs = Array.from(document.querySelectorAll('.calc-input'));
    const emptyInput = allInputs.find(input => 
      !input.disabled && !input.classList.contains('is-correct') && input.value === ""
    );
    if (emptyInput) {
      emptyInput.focus();
    } else {
      const notCorrect = document.querySelector('.calc-input:not(:disabled):not(.is-correct)');
      if (notCorrect) notCorrect.focus();
    }
  };

  function getActiveOrLastCell() {
    let activeInput = document.activeElement;
    if (activeInput && activeInput.classList.contains('calc-input')) {
      return activeInput;
    }
    if (lastActiveCell && !lastActiveCell.disabled && !lastActiveCell.classList.contains('is-correct')) {
      lastActiveCell.focus();
      return lastActiveCell;
    }
    focusFirstEmptyCell();
    return document.activeElement.classList.contains('calc-input') ? document.activeElement : null;
  }

  // --- 2. ゲーム進行制御 ---

  // 設定を変えた時、スタート前なら表をプレビューして、結果表示などを消す
  window.previewTable = function() {
    currentMode = document.getElementById('mode-select').value;
    currentCount = parseInt(document.getElementById('count-select').value, 10);
    generateTable(currentMode, currentCount, true);
    
    // 結果表示を隠し、ボタンを「スタート！」に戻す
    document.getElementById('result-display-area').classList.add('d-none');
    const startBtn = document.getElementById('start-btn');
    startBtn.innerHTML = '<i class="bi bi-play-circle-fill"></i> スタート！';
  };

  window.startGame = function() {
    document.getElementById('mode-select').disabled = true;
    document.getElementById('count-select').disabled = true;
    document.getElementById('start-btn').style.display = 'none';
    
    // 結果表示を隠す
    document.getElementById('result-display-area').classList.add('d-none');

    generateTable(currentMode, currentCount, false);

    lastActiveCell = null; 
    const firstInput = document.querySelector('input[data-row="0"][data-col="0"]');
    if (firstInput) {
      firstInput.focus();
      lastActiveCell = firstInput;
    }

    document.getElementById('manual-finish-btn').style.display = appSettings.autoScore ? 'none' : 'inline-block';

    resizeCanvas();
    if(window.clearAllCanvas) clearAllCanvas(true);
    startTimer();
  };

  window.finishGame = function() {
    clearInterval(timerInterval);
    playSound('end'); 
    
    let score = 0;
    const inputs = document.querySelectorAll('.calc-input');
    
    inputs.forEach(input => {
      let val = input.value;
      const r = parseInt(input.getAttribute('data-row'), 10);
      const c = parseInt(input.getAttribute('data-col'), 10);
      const rowVal = tableData.rows[r];
      const colVal = tableData.cols[c];
      
      let correctAnswer;
      if (currentMode === 'たし算') correctAnswer = rowVal + colVal;
      else if (currentMode === '引き算') correctAnswer = rowVal - colVal;
      else if (currentMode === 'かけ算') correctAnswer = rowVal * colVal;

      if (val !== "" && parseInt(val, 10) === correctAnswer) {
        score++;
        input.classList.remove('is-wrong');
        input.classList.add('is-correct');
      } else {
        input.classList.add('is-wrong');
        if (!appSettings.autoScore) {
           input.type = "text"; 
           input.value = val === "" ? `無答 ➡ ${correctAnswer}` : `${val} ➡ ${correctAnswer}`;
           input.style.fontSize = "0.9rem";
        }
      }
      input.disabled = true; 
    });

    finalScore = score;
    finalTime = document.getElementById('timer-display').innerText;

    // ★ 画面遷移なし！その場に結果を表示する
    document.getElementById('main-result-score').innerText = finalScore + ' / ' + currentCount;
    document.getElementById('main-result-time').innerText = finalTime;
    document.getElementById('result-display-area').classList.remove('d-none');
    
    // ★ 設定の変更を許可し、「もういちど！」ボタンを復活させる
    document.getElementById('mode-select').disabled = false;
    document.getElementById('count-select').disabled = false;
    
    const startBtn = document.getElementById('start-btn');
    startBtn.style.display = 'inline-block';
    startBtn.innerHTML = '<i class="bi bi-arrow-clockwise"></i> もういちど！';
    
    document.getElementById('manual-finish-btn').style.display = 'none';

    // 裏で静かに記録を送信する（全画面ローディングは行わない）
    submitRecord();
  };

  // --- 3. 問題生成と入力制御 ---
  function generateTable(mode, count, isDisabled) {
    const container = document.getElementById('calc-table-container');
    const colsCount = 10;
    const rowsCount = count / 10;

    tableData.cols = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9].sort(() => Math.random() - 0.5);
    tableData.rows = [];

    for (let i = 0; i < rowsCount; i++) {
      if (mode === '引き算') {
        tableData.rows.push(Math.floor(Math.random() * 10) + 10);
      } else {
        tableData.rows.push(Math.floor(Math.random() * 10));
      }
    }

    let operatorSymbol = mode === 'たし算' ? '+' : (mode === '引き算' ? '-' : '×');
    let html = '<table class="calc-table"><thead><tr>';
    html += `<th class="operator-cell">${operatorSymbol}</th>`;
    
    tableData.cols.forEach(num => { html += `<th>${num}</th>`; });
    html += '</tr></thead><tbody>';

    const disabledAttr = isDisabled ? 'disabled' : '';

    for (let r = 0; r < rowsCount; r++) {
      html += '<tr>';
      html += `<th>${tableData.rows[r]}</th>`; 
      for (let c = 0; c < colsCount; c++) {
        html += `<td><input type="tel" class="calc-input" data-row="${r}" data-col="${c}" oninput="handleInput(this)" onfocus="lastActiveCell=this" ${disabledAttr}></td>`;
      }
      html += '</tr>';
    }
    html += '</tbody></table>';
    container.innerHTML = html;
  }

  window.handleInput = function(inputElem) {
    let val = inputElem.value;
    val = val.replace(/[０-９]/g, function(s) { return String.fromCharCode(s.charCodeAt(0) - 0xFEE0); });
    val = val.replace(/[^0-9-]/g, '');
    inputElem.value = val;

    if (val === "") {
      inputElem.classList.remove('is-wrong');
      return;
    }

    if (!appSettings.autoScore) {
      inputElem.classList.remove('is-wrong');
      inputElem.classList.remove('is-correct');
      return;
    }

    const r = parseInt(inputElem.getAttribute('data-row'), 10);
    const c = parseInt(inputElem.getAttribute('data-col'), 10);
    const rowVal = tableData.rows[r];
    const colVal = tableData.cols[c];
    
    let correctAnswer;
    if (currentMode === 'たし算') correctAnswer = rowVal + colVal;
    else if (currentMode === '引き算') correctAnswer = rowVal - colVal;
    else if (currentMode === 'かけ算') correctAnswer = rowVal * colVal;

    if (parseInt(val, 10) === correctAnswer) {
      inputElem.classList.remove('is-wrong');
      inputElem.classList.add('is-correct');
      inputElem.disabled = true;
      playSound('correct');
      
      if(window.clearAllCanvas) clearAllCanvas(true); 
      moveToNextCell(r, c);
    } else {
      if (val.length >= String(correctAnswer).length) {
        inputElem.classList.add('is-wrong');
        playSound('incorrect');
      } else {
        inputElem.classList.remove('is-wrong');
      }
    }
  };

  function playSound(type) {
    if (!appSettings.sound) return; 
    if (sounds[type]) {
      sounds[type].currentTime = 0;
      sounds[type].play().catch(e => console.log("音声再生ブロック:", e));
    }
  }

  // --- ★ソフトウェア・テンキー処理 ---
  window.inputNumpad = function(val) {
    let activeInput = getActiveOrLastCell(); 
    if (!activeInput) return;
    if (activeInput.disabled || activeInput.classList.contains('is-correct')) return;

    if (val === 'back') {
      activeInput.value = activeInput.value.slice(0, -1);
    } else {
      activeInput.value += val;
    }
    
    handleInput(activeInput);
  };

  window.focusNextCell = function() {
    let activeInput = getActiveOrLastCell();
    if (!activeInput) return;
    const r = parseInt(activeInput.getAttribute('data-row'), 10);
    const c = parseInt(activeInput.getAttribute('data-col'), 10);
    moveToNextCell(r, c);
  };

  function moveToNextCell(r, c) {
    let nextC = c + 1;
    let nextR = r;
    if (nextC >= 10) {
      nextC = 0;
      nextR++;
    }
    
    const nextInput = document.querySelector(`input[data-row="${nextR}"][data-col="${nextC}"]`);
    if (nextInput) {
      nextInput.focus();
    } else {
      checkAllComplete();
    }
  }

  function checkAllComplete() {
    if (!appSettings.autoScore) return;
    const allInputs = document.querySelectorAll('.calc-input');
    const correctInputs = document.querySelectorAll('.calc-input.is-correct');
    if (allInputs.length > 0 && allInputs.length === correctInputs.length) {
      finishGame(); 
    }
  }

  // --- 4. タイマー処理 ---
  function startTimer() {
    startTime = Date.now();
    const display = document.getElementById('timer-display');
    display.innerText = "0.0";

    timerInterval = setInterval(() => {
      let elapsed = (Date.now() - startTime) / 1000;
      finalTime = elapsed.toFixed(1);
      display.innerText = finalTime;
    }, 100);
  }

  // --- 5. 2つの手書きキャンバスとAI文字認識 ---
  function initCanvas() {
    canvases[0] = document.getElementById('handwriting-canvas-1');
    canvases[1] = document.getElementById('handwriting-canvas-2');
    
    for (let i = 0; i < 2; i++) {
      if (!canvases[i]) continue;
      ctxs[i] = canvases[i].getContext('2d');

      canvases[i].addEventListener('mousedown', (e) => startPosition(e, i));
      canvases[i].addEventListener('mouseup', (e) => endPosition(e, i));
      canvases[i].addEventListener('mousemove', (e) => draw(e, i));
      canvases[i].addEventListener('mouseout', (e) => endPosition(e, i));

      canvases[i].addEventListener('touchstart', (e) => handleTouchStart(e, i), {passive: false});
      canvases[i].addEventListener('touchend', (e) => endPosition(e, i));
      canvases[i].addEventListener('touchmove', (e) => handleTouchMove(e, i), {passive: false});
    }
  }

  function resizeCanvas() {
    if (!appSettings.handwriting) return;
    if (!canvases || canvases.length === 0) return;
    for (let i = 0; i < 2; i++) {
      if (!canvases[i]) continue;
      const container = canvases[i].parentElement;
      canvases[i].width = container.clientWidth;
      canvases[i].height = container.clientHeight; 
    }
    if(window.clearAllCanvas) clearAllCanvas(true);
  }

  window.clearAllCanvas = function(resetDirty = true) {
    for (let i = 0; i < 2; i++) {
      if(ctxs[i] && canvases[i]) {
        ctxs[i].fillStyle = '#ffffff';
        ctxs[i].fillRect(0, 0, canvases[i].width, canvases[i].height);
        if(resetDirty) isCanvasDirty[i] = false;
      }
    }
    if(resetDirty) clearTimeout(ocrTimer);
  };

  function getPosition(e, i) {
    const rect = canvases[i].getBoundingClientRect();
    const scaleX = canvases[i].width / rect.width;
    const scaleY = canvases[i].height / rect.height;
    return {
      x: (e.clientX - rect.left) * scaleX,
      y: (e.clientY - rect.top) * scaleY
    };
  }

  function startPosition(e, i) {
    if (!appSettings.handwriting) return; 
    isDrawing[i] = true;
    isCanvasDirty[i] = true;
    clearTimeout(ocrTimer); 
    const pos = getPosition(e, i);
    lastX[i] = pos.x;
    lastY[i] = pos.y;
    draw(e, i);
  }

  function endPosition(e, i) {
    if (!isDrawing[i]) return;
    isDrawing[i] = false;
    ctxs[i].beginPath();
    
    clearTimeout(ocrTimer);
    ocrTimer = setTimeout(recognizeHandwriting, 800);
  }

  function draw(e, i) {
    if (!isDrawing[i]) return;
    isCanvasDirty[i] = true;
    clearTimeout(ocrTimer);
    
    const pos = getPosition(e, i);
    
    ctxs[i].lineWidth = 12; 
    ctxs[i].lineCap = 'round';
    ctxs[i].lineJoin = 'round';
    ctxs[i].strokeStyle = '#000000'; 

    ctxs[i].beginPath();
    ctxs[i].moveTo(lastX[i], lastY[i]);
    ctxs[i].lineTo(pos.x, pos.y);
    ctxs[i].stroke();
    
    lastX[i] = pos.x;
    lastY[i] = pos.y;
  }

  function handleTouchStart(e, i) {
    e.preventDefault(); 
    const touch = e.touches[0];
    const mouseEvent = new MouseEvent("mousedown", { clientX: touch.clientX, clientY: touch.clientY });
    startPosition(mouseEvent, i);
  }

  function handleTouchMove(e, i) {
    e.preventDefault(); 
    const touch = e.touches[0];
    const mouseEvent = new MouseEvent("mousemove", { clientX: touch.clientX, clientY: touch.clientY });
    draw(mouseEvent, i);
  }

  async function recognizeHandwriting() {
    if (!appSettings.handwriting || !tfModel) return; 
    
    if (!isCanvasDirty[0] && !isCanvasDirty[1]) return;
    
    let activeInput = getActiveOrLastCell(); 
    if (!activeInput || activeInput.disabled || activeInput.classList.contains('is-correct')) return;

    const statusEl = document.getElementById('ocr-status');
    statusEl.innerHTML = '<span class="spinner-border spinner-border-sm text-primary"></span> 読み取り中...';
    
    try {
      let finalNumberStr = "";
      
      for (let i = 0; i < 2; i++) {
        if (isCanvasDirty[i]) {
          const tensor = preprocessCanvas(canvases[i]);
          if (!tensor) continue;

          const output = tfModel.predict(tensor);
          const digit = output.argMax(1).dataSync()[0];
          const probability = output.max().dataSync()[0];

          tensor.dispose();
          output.dispose();
          
          if (probability > 0.4) {
            finalNumberStr += String(digit);
          }
        }
      }

      if (finalNumberStr.length > 0) {
        statusEl.innerText = "「" + finalNumberStr + "」を入力しました";
        
        activeInput.value = finalNumberStr;
        handleInput(activeInput);
        
        if (!appSettings.autoScore) {
           moveToNextCell(
             parseInt(activeInput.getAttribute('data-row'), 10), 
             parseInt(activeInput.getAttribute('data-col'), 10)
           );
           if(window.clearAllCanvas) clearAllCanvas(true);
        }
        
      } else {
        statusEl.innerText = "数字がわかりませんでした";
      }

    } catch(err) {
      console.error(err);
      statusEl.innerText = "エラーがおきました";
      if(window.clearAllCanvas) clearAllCanvas(true);
    }
  }

  function preprocessCanvas(sourceCanvas) {
    const sCtx = sourceCanvas.getContext('2d');
    const imgData = sCtx.getImageData(0, 0, sourceCanvas.width, sourceCanvas.height);
    const data = imgData.data;
    
    let minX = sourceCanvas.width, minY = sourceCanvas.height, maxX = 0, maxY = 0;
    let found = false;
    for (let y = 0; y < sourceCanvas.height; y++) {
      for (let x = 0; x < sourceCanvas.width; x++) {
        const idx = (y * sourceCanvas.width + x) * 4;
        if (data[idx+3] > 0 && data[idx] < 128) { 
          if (x < minX) minX = x;
          if (x > maxX) maxX = x;
          if (y < minY) minY = y;
          if (y > maxY) maxY = y;
          found = true;
        }
      }
    }
    if (!found) return null;

    const bWidth = maxX - minX + 1;
    const bHeight = maxY - minY + 1;
    const size = Math.max(bWidth, bHeight);
    const padding = size * 0.25; 
    const paddedSize = size + padding * 2;

    const tmpCanvas = document.createElement('canvas');
    tmpCanvas.width = paddedSize;
    tmpCanvas.height = paddedSize;
    const tmpCtx = tmpCanvas.getContext('2d');
    tmpCtx.fillStyle = '#ffffff';
    tmpCtx.fillRect(0, 0, paddedSize, paddedSize);
    
    const dx = padding + (size - bWidth) / 2;
    const dy = padding + (size - bHeight) / 2;
    tmpCtx.drawImage(sourceCanvas, minX, minY, bWidth, bHeight, dx, dy, bWidth, bHeight);

    const resizedCanvas = document.createElement('canvas');
    resizedCanvas.width = 28;
    resizedCanvas.height = 28;
    const resizedCtx = resizedCanvas.getContext('2d');
    resizedCtx.drawImage(tmpCanvas, 0, 0, paddedSize, paddedSize, 0, 0, 28, 28);

    const resizedData = resizedCtx.getImageData(0, 0, 28, 28).data;
    const input = new Float32Array(28 * 28);
    for (let i = 0; i < 28 * 28; i++) {
      const r = resizedData[i * 4];
      input[i] = (255 - r) / 255.0; 
    }
    
    return tf.tensor4d(input, [1, 28, 28, 1]);
  }

  // --- 6. GAS通信ラッパー (裏で静かに送信) ---
  function submitRecord() {
    const recordData = {
      mode: currentMode,
      count: currentCount,
      score: finalScore,
      time: parseFloat(finalTime)
    };
    // ★ローディングで画面を止めず、裏でこっそり送る
    callGasWithRetry(recordData, 1);
  }

  function callGasWithRetry(data, attempt) {
    const MAX_RETRIES = 3;

    google.script.run
      .withSuccessHandler(function(response) {
        if (response.success) {
          // 右上に小さく成功を通知（邪魔にならない）
          Swal.fire({
            toast: true,
            position: 'top-end',
            icon: 'success',
            title: 'きろくを ほぞんしました！',
            showConfirmButton: false,
            timer: 2000
          });
        } else {
          if (attempt < MAX_RETRIES) {
            setTimeout(() => callGasWithRetry(data, attempt + 1), 2000); 
          }
        }
      })
      .withFailureHandler(function(error) {
        if (attempt < MAX_RETRIES) {
          setTimeout(() => callGasWithRetry(data, attempt + 1), 2000);
        }
      })
      .saveRecord(data);
  }
</script>
